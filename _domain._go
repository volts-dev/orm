package orm

import (
	"errors"
	"fmt"
	"strings"
	"webgo/utils"
)

type (

	// lexer提供数据的扫描工作
	TLexer struct {
		length int
		stream string //即将被扫描的文件流 一般放在执行扫描的类里
		//leftdelim  string //开始的标志
		//rightdelim string //结束的标志
		pos int // 当前游标

		curline int
		char    byte
		isEof   bool
		/*
			begin     int //从这里开始
			end       int //结束的地方
			offset    int // current position in the input.
			ch        rune
			width     int // width of last rune read from input.
			insideTag bool
		*/
	}

	// Parser 提供解析的逻辑 和数据的变换
	TStringParser struct {
		//templete *Parser
		//parent   *Parser
		lexer   *TLexer
		strings *utils.TStringList
	}
)

func _new_domain(domain ...string) *utils.TStringList {
	if len(domain) == 0 || (len(domain) == 1 && domain[0] == "") {
		result := utils.NewStringList()

		result.FormatFunc(_update)
		return result
	}

	lLexer := &TLexer{
		stream: domain[0],
		length: len(domain[0]),
		pos:    0,
		isEof:  false,
	}

	lParse := &TStringParser{
		lexer:   lLexer,
		strings: utils.NewStringList(),
	}

	err := lParse.parse()
	if err != nil {
		return nil
	}

	result := lParse.strings //.Item(0)

	result.FormatFunc(_update)
	return result
}

func Domain2StringList(strs ...string) *utils.TStringList {
	return _new_domain(strs...)
}

//主要-移动偏移
//
func (self *TLexer) next() byte {
	if self.pos >= self.length-1 { //如果大于Buf 则停止
		//selfl.width = 0
		self.isEof = true
		return 0
	}
	//utils.Dbg("next", self.pos, self.stream[self.pos])
	// 直接返回第一个字符
	if self.pos == 0 && self.char == 0 {
		self.char = self.stream[self.pos]
		//self.pos += 1
		return self.char
	}

	self.pos += 1
	self.char = self.stream[self.pos]
	return self.char
}

func (self *TLexer) backup() {
	if self.pos > 0 {
		self.pos--
	}
	self.char = self.stream[self.pos]
}

//主要-略过特殊字符移动
//保持上一个有效字符
func (self *TLexer) consume_whitespace() {
	lChar := self.char
	for {
		self.next()
		if self.isEof {
			break
		}

		//utils.Dbg("consume_whitespace", string(self.char))
		if self.char == ' ' || self.char == '\t' || self.char == '\n' || self.char == '\r' {
			continue
		} else {
			self.backup()
			//utils.Dbg("consume_whitespace", string(self.char))
			break
			//return self.char
		}
	}

	self.char = lChar
	//utils.Dbg("consume_whitespace", string(self.char))
}

// 判断扫描 {{
/*
	循环匹配 {{ 直到找到完全匹配的
*/

func (self *TLexer) scan_string(s string) string { // s={{
	var (
		lStr string
		//		lChar byte
		pos int

		//		match bool = true
		//		err error
	)

	if s == "" {
		return "" //, errors.New("invaid string")
	}

	// 如果查询的超出范围
	if self.pos+len(s) >= self.length { //是否已经到末端了??
		lStr = self.stream[self.pos:]
		self.pos = self.length // 移到末端
		return lStr            //, io.EOF    //如果是-->获取当前游标以后的数据
	}

	pos = self.pos + 1
	for { //循环直到匹配到"{{"返回
		self.consume_whitespace()
		self.next()
		if self.isEof {
			return ""
		}
		//if self.stream[cur_pos] == '\n' { //判断是否到行末
		//	newlines++
		//}

		// 直到找到 第一个 和S 要查询的字符一样
		if self.char != s[0] { //当前是不是 目标字符
			continue //重新循环
		}

		//pos = self.pos                    //偏移到包含 S之内的 游标地址
		text := self.stream[pos:self.pos] //读取{{这段数据
		//self.pos = pos                    //设置偏移为当前偏移					/* 2 offset n */

		//utils.Dbg("scan_string match", pos, self.pos)
		return text

		// 没找到的话继续循环,这是转向下一个字符的唯一代码
	}

	//should never be here
	return ""
}

// s Html文件流
/*
[('foo', '=', 'bar')]
foo = 'bar'

[('id', 'in', [1,2,3])]
id in (1, 2, 3)

[('field', '=', 'value'), ('field', '<>', 42)]
( field = 'value' AND field <> 42 )

[('&', ('field', '<', 'value'), ('field', '>', 'value'))]
( field < 'value' AND field > 'value' )

[('|', ('field', '=', 'value'), ('field', '=', 'value'))]
( field = 'value' OR field = 'value' )

[('&', ('field1', '=', 'value'), ('field2', '=', 'value'), ('|', ('field3', '<>', 'value'), ('field4', '=', 'value')))]
( field1 = 'value' AND field2 = 'value' AND ( field3 <> 'value' OR field4 = 'value' ) )

[('&', ('|', ('a', '=', 1), ('b', '=', 2)), ('|', ('c', '=', 3), ('d', '=', 4)))]
( ( a = 1 OR b = 2 ) AND ( c = 3 OR d = 4 ) )

[('|', (('a', '=', 1), ('b', '=', 2)), (('c', '=', 3), ('d', '=', 4)))]
( ( a = 1 AND b = 2 ) OR ( c = 3 AND d = 4 ) )
*/
// ['&', ('active', '=', True), ('value', '!=', 'foo')]
// ['|', ('active', '=', True), ('state', 'in', ['open', 'draft'])
// ['&', ('active', '=', True), '|', '!', ('state', '=', 'closed'), ('state', '=', 'draft')]
// ['|', '|', ('state', '=', 'open'), ('state', '=', 'closed'), ('state', '=', 'draft')]
// ['!', '&', '!', ('id', 'in', [42, 666]), ('active', '=', False)]
// ['!', ['=', 'company_id.name', ['&', ..., ...]]]
//	[('picking_id.picking_type_id.code', '=', 'incoming'), ('location_id.usage', '!=', 'internal'), ('location_dest_id.usage', '=', 'internal')]

func (self *TStringParser) _parselist(list *utils.TStringList) error {
	// 处理规则
	// List 不直接跳出 [('field', '=', 'value'), ('field', '<>', 42)] 如果处理到第一个跳出 第二个则无法继续
	// 存储值的List 可以直接跳出 例如：('id', 'in', [42, 666])  100%确定不需要处理其他List

	var (
		lPos  int = 0
		lStr  string
		lVals []string
		char  string
	)

	//utils.Dbg("begin for")
	// 不是文件末端
	for !self.lexer.isEof {

		// 忽略空白
		self.lexer.consume_whitespace()

		//utils.Dbg("switch", string(self.lexer.char))
		char = string(self.lexer.char)
		switch char {
		case "(", "[": //('active', '=', True)
			{
				// 新建链
				lLst := &utils.TStringList{StartPos: self.lexer.pos}

				// 移动游标到下一个非空格
				self.lexer.consume_whitespace()
				self.lexer.next()
				if self.lexer.isEof {
					goto exit
				}

				/*	if isAlphaNumeric(rune(self.lexer.char)) {
						lStr = self.lexer.scan_string(")")
						if self.lexer.isEof {
							goto exit
						}
						utils.Dbg("(", string(self.lexer.char), lStr)
						lVals = strings.Split(lStr, ",")
						for _, val := range lVals {
							lLst.items = append(lLst.items, &TStringList{text: val})
						}

					} else { // ['&', (
						utils.Dbg("(", string(self.lexer.char), lStr)
				*/
				//self.lexer.backup()
				if utils.IsAlphaNumericRune(rune(self.lexer.char)) { // [1,2,3]
					self.lexer.backup()
					lStr = self.lexer.scan_string("]")
					if self.lexer.isEof {
						goto exit
					}

					//utils.Dbg("New val ", string(self.lexer.char), lStr)

					lVals = strings.Split(lStr, ",")
					for _, val := range lVals {
						//lLst.items = append(lLst.items, &utils.TStringList{text: val})
						lLst.Push(utils.NewStringList(val))
					}

					// 读写字符串传
					lLst.EndPos = self.lexer.pos + 1
					//lLst.text = self.lexer.stream[lLst.StartPos:lLst.ndPos]
					lLst.SetText(self.lexer.stream[lLst.StartPos:lLst.EndPos])
					//utils.Dbg("list text", lLst.text)

					// 插入
					//list.items = append(list.items, lLst)
					list.Push(lLst)

					// 继续处理后面的")"  ...[42, 666])
					self.lexer.consume_whitespace()
					self.lexer.next()
					if self.lexer.isEof {
						goto exit
					}

					if self.lexer.char == ')' || self.lexer.char == ']' {
						goto exit // 列表末端 跳出
						break
					} else {
						self.lexer.backup() // 回滚 继续
					}
				} else { // ['&', (
					//utils.Dbg("[ into parselist", string(self.lexer.char), lStr)
					err := self._parselist(lLst)
					if err != nil {

					}

					//self.lexer.consume_whitespace()
					//self.lexer.next()
					//lStr = self.lexer.scan_string("]")
					//utils.Dbg("list rnd", lLst.text)
				}
				//}
				lLst.EndPos = self.lexer.pos + 1
				//lLst.text = self.lexer.stream[lLst.startPos:lLst.endPos]
				lLst.SetText(self.lexer.stream[lLst.StartPos:lLst.EndPos])
				//fmt.Println("()list ( text", lLst.text)
				//list.items = append(list.items, lLst)
				list.Push(lLst)
				//goto exit // NOTE:末尾不能直接跳出，有可能有下一个Listt要执行
			}
			/*
				case "[": //['&', ('active', '=', True), ('value', '!=', 'foo')]
					{
						// 新建链
						lLst := &TStringList{startPos: self.lexer.pos}

						self.lexer.consume_whitespace()
						self.lexer.next()
						if self.lexer.isEof {
							goto exit
						}

						if isAlphaNumeric(rune(self.lexer.char)) { // [1,2,3]
							self.lexer.backup()
							lStr = self.lexer.scan_string("]")
							if self.lexer.isEof {
								goto exit
							}

							//utils.Dbg("New val ", string(self.lexer.char), lStr)

							lVals = strings.Split(lStr, ",")
							for _, val := range lVals {
								lLst.items = append(lLst.items, &TStringList{text: val})
							}

							// 读写字符串传
							lLst.endPos = self.lexer.pos + 1
							lLst.text = self.lexer.stream[lLst.startPos:lLst.endPos]
							//utils.Dbg("list text", lLst.text)

							// 插入
							list.items = append(list.items, lLst)

							// 继续处理后面的")"  ...[42, 666])
							self.lexer.consume_whitespace()
							self.lexer.next()
							if self.lexer.isEof {
								goto exit
							}

							if self.lexer.char == ')' || self.lexer.char == ']' {
								goto exit // 列表末端 跳出
								break
							} else {
								self.lexer.backup() // 回滚 继续
							}
						} else { // ['&', (
							//utils.Dbg("[ into parselist", string(self.lexer.char), lStr)
							err := self._parselist(lLst)
							if err != nil {

							}

							//self.lexer.consume_whitespace()
							//self.lexer.next()
							//lStr = self.lexer.scan_string("]")
							//utils.Dbg("list rnd", lLst.text)
						}

						// 读写字符串传
						lLst.endPos = self.lexer.pos + 1
						lLst.text = self.lexer.stream[lLst.startPos:lLst.endPos]
						//utils.Dbg("[]list text", lLst.text)

						// 插入
						list.items = append(list.items, lLst)

						//goto exit // NOTE:末尾不能直接跳出，有可能有下一个Listt要执行
					}
			*/
		case "'", `"`:
			{

				//获取另一个引号 ('xx's', 可能字符有"’" 所以必须遇见","
				for {
					lStr = self.lexer.scan_string(char)
					if self.lexer.isEof {
						goto exit
					}
					//utils.Dbg("':", string(self.lexer.char), lStr)

					// 确定下一个字符是 "," 这是一个Block结束
					self.lexer.consume_whitespace()
					self.lexer.next()
					if self.lexer.isEof {
						goto exit
					}
					if self.lexer.char == ',' {
						//utils.Dbg("New text", lStr)
						//list.items = append(list.items, &TStringList{text: lStr})
						list.Push(utils.NewStringList(lStr))
						self.lexer.backup()
						//utils.Dbg("New backup", string(self.lexer.char))
						break // 推出循环
					} else if self.lexer.char == ')' || self.lexer.char == ']' {
						//utils.Dbg("New text", lStr)
						//list.items = append(list.items, &TStringList{text: lStr})
						list.Push(utils.NewStringList(lStr))
						// NOTE: 列表末尾不backup
						goto exit // 结束列表
					}
				}
			}

		case ",":
			{
				// 如果","的下一个字符是数字字母并“）]”结束 则取值
				// 否则 跳出循环
				self.lexer.consume_whitespace()
				lPos = self.lexer.pos + 1 // 减","
				for {
					self.lexer.consume_whitespace()
					self.lexer.next()
					if self.lexer.isEof {
						goto exit
					}

					// 如果是字母数字 向下
					if utils.IsAlphaNumericRune(rune(self.lexer.char)) {
						continue
					} else {
						if self.lexer.char == ']' || self.lexer.char == ')' {
							lStr = self.lexer.stream[lPos:self.lexer.pos]
							//list.items = append(list.items, &utils.TStringList{text: lStr})
							list.Push(utils.NewStringList(lStr))
							//utils.Dbg("New text", lStr)
							goto exit

							// 以下代码不执行
							self.lexer.consume_whitespace()
							self.lexer.next()
							if self.lexer.isEof {
								goto exit
							}
							if self.lexer.char == ']' || self.lexer.char == ')' {
								goto exit
							}

						} else {
							// 回退1 并跳出For
							self.lexer.backup()
							break
						}
					}
				}

				//bracket = 1
			}
		default:
			{
				//bracket = 0
			}
		}
		//	utils.Dbg("end")
		self.lexer.consume_whitespace()
		self.lexer.next()
	}

exit:
	return nil
}

// 解析
func (self *TStringParser) parse() error {
	//utils.Dbg("domain", self.lexer.stream)

	// 检查合法性
	if !strings.HasPrefix(self.lexer.stream, "[") && !strings.HasSuffix(self.lexer.stream, "]") {
		//utils.Dbg("invaild domain")
		return errors.New("invaild domain")
	}

	return self._parselist(self.strings)
}
